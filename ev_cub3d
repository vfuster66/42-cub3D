#ifndef CUB3D_H
#define CUB3D_H

# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <stdbool.h>
# include <fcntl.h>
# include <limits.h>
# include <unistd.h>
# include <ctype.h>
# include <math.h>
# include <X11/keysym.h>
# include <X11/X.h>
# include "../libft/includes/libft.h"
# include "../mlx_linux/mlx.h"

# define MAX_WIDTH 1024
# define MAX_HEIGHT 768
# define TEXTURE_WIDTH 64
# define TEXTURE_HEIGHT 64
# define CELL_SIZE 10
# define BUFFER_SIZE 1024

# define RESET "0xff0000"

# define ERR_MLX_START "Could not start mlx"
# define ERR_MLX_WIN "Could not create mlx window"
# define ERR_MLX_IMG "Could not create mlx image"

# define KeyPress 2
# define KeyPressMask (1L<<0)

/*---------- STRUCTURES ----------*/

typedef enum e_key_code
{
	CLOSE_ICON = 17,
	ESC_KEY = 65307,
	KEY_PRESS = 2,
	KEY_RELEASE = 3,
	UP_KEY = 65362,
	DOWN_KEY = 65364,
	LEFT_KEY = 65363,
	RIGHT_KEY = 65361,
	W_KEY = 119,
	A_KEY = 97,
	S_KEY = 115,
	D_KEY = 100
}	t_key_code;

typedef struct s_key_state {
	bool W;
	bool S;
	bool A;
	bool D;
} t_key_state;

extern t_key_state g_keystate;

// Texture
typedef struct s_texture
{
	void	*img;
	char	*path;
	char	*addr;
	int		width;
	int		height;
	int		bits_per_pixel;
	int		line_length;
	int		endian;
}				t_texture;

// Raycast
typedef struct s_ray
{
	t_texture	*wall_texture;
	double		camera_x;
	double		ray_dir_x;
	double		ray_dir_y;
	int			map_x;
	int			map_y;
	double		side_dist_x;
	double		side_dist_y;
	double		delta_dist_x;
	double		delta_dist_y;
	double		perp_wall_dist;
	int			step_x;
	int			step_y;
	int			hit;
	int			side;
	int			tex_x;
}				t_ray;

// Window
typedef struct s_mlx
{
	void	*mlx;
	void	*win;
	void	*img;
	char	*title;
	char	*addr;
	int		endian;
	int		bits_per_pixel;
	int		line_length;
	int		win_width;
	int		win_height;
}				t_mlx;

// Image
typedef struct s_img
{
	void	*img;
	char	*addr;
	int		bits_per_pixel;
	int		line_length;
	int		endian;
}				t_img;

// Map
typedef struct s_map
{
	char		*north_texture_path;
	char		*south_texture_path;
	char		*west_texture_path;
	char		*east_texture_path;
	t_texture	north_texture;
	t_texture	south_texture;
	t_texture	east_texture;
	t_texture	west_texture;
	t_mlx		*mlx_ref;
	int			width;
	int			height;
	char		**map;
	int			start_x;
	int			start_y;
	int			player_x;
	int			player_y;
	int			player_direction;
	bool		floor_color_set;
	bool		ceiling_color_set;
	int			ceiling_color[3];
	int			floor_color[3];
	bool		config_done;
	char*		resolution_str;
	int			map_height;
}				t_map;

// Player
typedef struct s_player
{
	double	pos_x;
	double	pos_y;	
	double	dir_x;
	double	dir_y;
	double	plane_x; 
	double	plane_y;
}				t_player;

// Data
typedef struct s_data
{
	t_mlx		*mlx;
	t_map       *map;
	t_player    *player;
	t_img		*img;
}				t_data;

typedef struct s_game_context
{
	t_data		*data;
	t_mlx		*mlx_info;
	t_map		*map_info;
	t_player	*player;
}				t_game_context;

typedef struct s_line {
    char *line;
    struct s_line *next;
} t_line;

/*---------- FONCTIONS ----------*/
// Parsing Config
int			validate_resolution(const char *resolution_str);
int			validate_rgb(const char *rgb_str, int *rgb_arr);
int			validate_texture_path(const char *path);
int			handle_texture_and_color(char *key, char *value, t_map *map_info);
int			parse_config_line(char* line, t_map *map_info);
int			read_and_split_lines(int fd, char **line, char **saveptr, int *config_completed);
int			process_lines(int fd, t_map *map_info);
int			parse_config_file(const char* file_path, t_map *map_info);
// Parsing Map
int			is_wall_line(const char* line);
int			process_player_position(char *line, t_map *map_info, int line_number);
int			parse_map_line(char* line, t_map *map_info, int line_number);
ssize_t		read_file_to_buffer(int fd, char *buffer, size_t buffer_size);
int			handle_map_line(char *line, t_map *map_info, int *start_reading_map, int *line_number);
int			process_map_lines(char *buffer, t_map *map_info, int *start_reading_map, int *line_number);
int			open_file_for_parsing(const char *file_path);
int			parse_map(const char* file_path, t_map *map_info);
int			parse_file(const char* file_path, t_map *map_info);
/*-----------------------------------------------------------*/
// Check
int			check_file_accessibility(const char *filename);
int			check_arguments(int ac, char **av);
int			is_valid_character(char c);
int			validate_single_map_line(char *line, int line_number,
				int height, int *player_start_count);
int			validate_map(t_map *map_info);
/*----------------------------------------------------------*/
// Window
int			close_window(t_data *data);
int			keyboard_actions(int key, t_data *data);
void		set_window(t_data *data);
/*----------------------------------------------------------*/
// Init
void		initialize_player(t_player *player);
void		init_player(t_player *player, t_map *map_info);
void		init_ray(t_ray *ray);
void		init_img_clean(t_mlx *mlx);
bool		init_texture(void *mlx, t_texture *texture, char *path);
void		init_img(t_data *data, void *mlx, int width, int height);
bool		init_texture(void *mlx, t_texture *texture, char *file_path);
bool		init_all_textures(t_mlx *mlx_info, t_map *map_info);
/*----------------------------------------------------------*/
// Moves
void		move_forward(t_player *player, double move_speed);
void		move_backward(t_player *player, double move_speed);
void		rotate_right(t_player *player, double rot_speed);
void		rotate_left(t_player *player, double rot_speed);
void		move_left(t_player *player, double move_speed);
void		move_right(t_player *player, double move_speed);
int			handle_input(int keycode, t_data *data);
/*----------------------------------------------------------*/
// Raycast
void		calculate_ray_and_deltadist(t_data *data, t_ray *ray, int x);
void		calculate_step_and_sidedist(t_data *data, t_ray *ray);
void		calculate_dist(t_data *data, t_ray *ray);
int			calculate_height_wall(t_data *data, t_ray *ray);
void		cast_ray(t_data *data, t_ray *ray, int x);
/*----------------------------------------------------------*/
// Clean
void		clean_exit(t_mlx *mlx, t_map *map);
void		cleanup(t_map *map_info, t_mlx *mlx_info);
void		clean_textures(t_map *map);
/*----------------------------------------------------------*/
// Free
void		free_texture_paths(t_map *map_info);
void		free_map_lines(t_map *map_info);
void		free_map(t_map *map_info);
/*----------------------------------------------------------*/
// Error
int			err_msg(char *detail, char *str, int code);
int			err_msg_val(int detail, char *str, int code);
/*----------------------------------------------------------*/
// Principal
int			init_mlx_and_window(t_mlx *mlx_info);
bool		check_wall(t_map *map_info, int x, int y);
void		update_game(t_data *data, t_player *player);
/*----------------------------------------------------------*/
// Draw
void		my_mlx_pixel_put(t_img *img, int x, int y, int color);
bool		init_texture(void *mlx, t_texture *texture, char *file_path);
bool		init_all_textures(t_mlx *mlx_info, t_map *map_info);
void		draw_floor(t_data *data);
void		draw_ceiling(t_data *data);
void		draw_walls(t_data *data, t_ray *ray, int x);
void		render(t_data *data);

#endif

int	check_file_accessibility(const char *filename)
{
	int	fd;

	fd = open(filename, O_RDONLY);
	if (fd == -1)
	{
		perror("Error: Unable to open the file");
		return (1);
	}
	close(fd);
	return (0);
}

int	check_arguments(int ac, char **av)
{
	char	*extension;

	if (ac != 2 && ac != 3)
	{
		printf("Usage: %s <map_file.cub> [--save]\n", av[0]);
		return (1);
	}
	if (ac == 3 && strcmp(av[2], "--save") != 0)
	{
		printf("Error: Invalid argument. The third argument must be '--save'\n");
		return (1);
	}
	extension = strrchr(av[1], '.');
	if (extension == NULL || strcmp(extension, ".cub") != 0
		|| strlen(extension) != 4)
	{
		printf("Error: The map file must have a '.cub' extension.\n");
		return (1);
	}
	return (check_file_accessibility(av[1]));
}

int	is_valid_character(char c)
{
	return (c == '1' || c == '0' || c == 'N' || c == 'S' || c == 'E' || c == 'W');
}

int	validate_single_map_line(char *line, int i, int height, int *player_start_count)
{
	int	width;
	int	j;

	if (line == NULL)
	{
		return (0);
	}
	width = strlen(line);
	j = 0;
	while (j < width)
	{
		if (!is_valid_character(line[j]))
			return (0);
		if (line[j] == 'N' || line[j] == 'S' || line[j] == 'E' || line[j] == 'W')
			(*player_start_count)++;
		if ((i == 0 || i == height - 1 || j == 0 || j == width - 1) && line[j] != '1')
			return (0);
		j++;
	}
	return (1);
}

int	validate_map(t_map *map_info)
{
	int	height;
	int	player_start_count;
	int	i;

	if (map_info == NULL || map_info->map == NULL)
		return (0);
	height = map_info->height;
	player_start_count = 0;
	i = 0;
	while (i < height)
	{
		if (!validate_single_map_line(map_info->map[i], i, height, &player_start_count))
		{
			return (0);
		}
		i++;
	}
	if (player_start_count != 1)
		return (0);
	return (1);
}


void	clean_textures(t_map *map)
{
	if (map->north_texture.img)
	{
		mlx_destroy_image(map->mlx_ref, map->north_texture.img);
	}
	if (map->south_texture.img)
	{
		mlx_destroy_image(map->mlx_ref, map->south_texture.img);
	}
	if (map->west_texture.img)
	{
		mlx_destroy_image(map->mlx_ref, map->west_texture.img);
	}
	if (map->east_texture.img)
	{
		mlx_destroy_image(map->mlx_ref, map->east_texture.img);
	}
}

void	clean_exit(t_mlx *mlx, t_map *map)
{
	if(map)
		clean_textures(map);
	if (mlx->img)
		mlx_destroy_image(mlx->mlx, mlx->img);
	if (mlx->win)
		mlx_destroy_window(mlx->mlx, mlx->win);
	if (mlx->mlx)
	{
		mlx_destroy_display(mlx->mlx);
		free(mlx->mlx);
	}
	exit(1);
}

void	cleanup(t_map *map_info, t_mlx *mlx_info)
{
	if (mlx_info->title != NULL)
	{
		free(mlx_info->title);
		mlx_info->title = NULL;
	}
	free_map(map_info);
	if (mlx_info->win != NULL)
	{
		mlx_destroy_window(mlx_info->mlx, mlx_info->win);
	}
	if (mlx_info->mlx != NULL)
	{
		mlx_destroy_display(mlx_info->mlx);
		free(mlx_info->mlx);
	}
}


int	err_msg(char *detail, char *str, int code)
{
	ft_putstr_fd("\x1B[31m" "cub3D: Error", 2);
	if (detail)
	{
		ft_putstr_fd(": ", 2);
		ft_putstr_fd(detail, 2);
	}
	if (str)
	{
		ft_putstr_fd(": ", 2);
		ft_putstr_fd(str, 2);
	}
	ft_putstr_fd("\n" RESET, 2);
	return (code);
}

int	err_msg_val(int detail, char *str, int code)
{
	ft_putstr_fd("\x1B[31m" "cub3D: Error: ", 2);
	ft_putnbr_fd(detail, 2);
	ft_putstr_fd(": ", 2);
	ft_putstr_fd(str, 2);
	ft_putstr_fd("\n" RESET, 2);
	return (code);
}


void	free_texture_paths(t_map *map_info)
{
	if (map_info->north_texture_path != NULL)
	{
		free(map_info->north_texture_path);
		map_info->north_texture_path = NULL;
	}
	if (map_info->south_texture_path != NULL)
	{
		free(map_info->south_texture_path);
		map_info->south_texture_path = NULL;
	}
	if (map_info->west_texture_path != NULL)
	{
		free(map_info->west_texture_path);
		map_info->west_texture_path = NULL;
	}
	if (map_info->east_texture_path != NULL)
	{
		free(map_info->east_texture_path);
		map_info->east_texture_path = NULL;
	}
}

void	free_map_lines(t_map *map_info)
{
	int	i;

	i = 0;
	if (map_info->map != NULL)
	{
		while (i < map_info->height && map_info->map[i] != NULL)
		{
			free(map_info->map[i]);
			map_info->map[i] = NULL;
			i++;
		}
		free(map_info->map);
		map_info->map = NULL;
	}
}

void	free_map(t_map *map_info)
{
	if (map_info == NULL)
	{
		return ;
	}
	free_texture_paths(map_info);
	free_map_lines(map_info);
}

void	initialize_player(t_player *player)
{
	player->pos_x = 0.0;
	player->pos_y = 0.0;
	player->dir_x = 0.0;
	player->dir_y = 0.0;
	player->plane_x = 0.0;
	player->plane_y = 0.0;
}

void set_player_direction_and_plane(t_player *player, char direction)
{
    if (direction == 'N')
    {
        player->dir_x = 0.0; player->dir_y = -1.0;
        player->plane_x = 0.66; player->plane_y = 0.0;
    }
    else if (direction == 'S')
    {
        player->dir_x = 0.0; player->dir_y = 1.0;
        player->plane_x = -0.66; player->plane_y = 0.0;
    }
    else if (direction == 'W')
    {
        player->dir_x = -1.0; player->dir_y = 0.0;
        player->plane_x = 0.0; player->plane_y = -0.66;
    }
    else if (direction == 'E')
    {
        player->dir_x = 1.0; player->dir_y = 0.0;
        player->plane_x = 0.0; player->plane_y = 0.66;
    }
    else
    {
        printf("Erreur : Direction du joueur invalide ('%c').\n", direction);
        exit(EXIT_FAILURE);
    }
}

void init_player(t_player *player, t_map *map_info)
{
    int i;
    char direction;
    
    i = 0;
    while (i < map_info->height)
    {
        if (!process_player_position(map_info->map[i], map_info, i))
        {
            printf("Erreur : Impossible de trouver ou de traiter la position du joueur dans la carte.\n");
            exit(EXIT_FAILURE);
        }
        i++;
    }
    direction = map_info->player_direction;
    //player->pos_x = map_info->player_x;
    //player->pos_y = map_info->player_y;
    set_player_direction_and_plane(player, direction);
}

bool init_texture(void *mlx, t_texture *texture, char *file_path)
{
    texture->img = mlx_xpm_file_to_image(mlx, file_path, &texture->width, &texture->height);
    if (!texture->img)
    {
        printf("Failed to load texture from path: %s\n", file_path);
        return false;
    }

    texture->addr = mlx_get_data_addr(texture->img, &texture->bits_per_pixel, &texture->line_length, &texture->endian);
    if (!texture->addr)
    {
        printf("Failed to retrieve texture data address for path: %s\n", file_path);
        return false;
    }
    return true;
}

bool init_all_textures(t_mlx *mlx_info, t_map *map_info)
{
    if (map_info->north_texture_path && !init_texture(mlx_info->mlx, &map_info->north_texture, map_info->north_texture_path))
    {
        printf("Failed to initialize north texture.\n");
        return false;
    }

    if (map_info->south_texture_path && !init_texture(mlx_info->mlx, &map_info->south_texture, map_info->south_texture_path))
    {
        printf("Failed to initialize south texture.\n");
        return false;
    }

    if (map_info->west_texture_path && !init_texture(mlx_info->mlx, &map_info->west_texture, map_info->west_texture_path))
    {
        printf("Failed to initialize west texture.\n");
        return false;
    }

    if (map_info->east_texture_path && !init_texture(mlx_info->mlx, &map_info->east_texture, map_info->east_texture_path))
    {
        printf("Failed to initialize east texture.\n");
        return false;
    }
    return true;
}

void	init_ray(t_ray *ray)
{
	ray->camera_x = 0;
	ray->ray_dir_x = 0;
	ray->ray_dir_y = 0;
	ray->map_x = 0;
	ray->map_y = 0;
	ray->side_dist_x = 0;
	ray->side_dist_y = 0;
	ray->delta_dist_x = 0;
	ray->delta_dist_y = 0;
	ray->perp_wall_dist = 0;
	ray->step_x = 0;
	ray->step_y = 0;
	ray->hit = 0;
	ray->side = 0;
}

void	init_img_clean(t_mlx *mlx)
{
	mlx->img = NULL;
	mlx->addr = NULL;
	mlx->bits_per_pixel = 0;
	mlx->line_length = 0;
	mlx->endian = 0;
}

void init_img(t_data *data, void *mlx, int width, int height)
{
    data->img = (t_img *)malloc(sizeof(t_img));
    if (data->img == NULL)
    {
        printf("Error: Failed to allocate memory for image.\n");
        exit(EXIT_FAILURE);
    }
    data->img->img = mlx_new_image(mlx, width, height);
    if (data->img->img == NULL)
    {
        printf("Error: Image creation failed.\n");
        free(data->img);
        exit(EXIT_FAILURE);
    }
    data->img->addr = mlx_get_data_addr(data->img->img, &data->img->bits_per_pixel,
        &data->img->line_length, &data->img->endian);
    if (data->img->addr == NULL)
    {
        printf("Error: Failed to get data address from image.\n");
        mlx_destroy_image(mlx, data->img->img);
        free(data->img);
        exit(EXIT_FAILURE);
    }
}

int	close_window(t_data *data)
{
	mlx_destroy_image(data->mlx->mlx, data->img->img);
	mlx_destroy_window(data->mlx->mlx, data->mlx->win);
	mlx_destroy_display(data->mlx->mlx);
	free(data->mlx->mlx);
	exit(0);
}

int	keyboard_actions(int key, t_data *data)
{
	if (key == ESC_KEY)
		close_window(data);
	mlx_do_sync(data->mlx->mlx);
	return (0);
}

void set_window(t_data *data)
{
	if (data == NULL || data->mlx == NULL || data->mlx->win == NULL
		|| data->img == NULL || data->img->img == NULL)
	{
		printf("Erreur de pointeur null dans set_window.\n");
		exit(EXIT_FAILURE);
	}
	mlx_hook(data->mlx->win, KeyPress, KeyPressMask, keyboard_actions, data);
	mlx_put_image_to_window(data->mlx->mlx, data->mlx->win, data->img->img, 0, 0);
	mlx_hook(data->mlx->win, 17, 0L, close_window, data);
}

int	validate_resolution(const char *resolution_str)
{
	char	*endptr;
	long	width;
	long	height;

	width = strtol(resolution_str, &endptr, 10);
	if (resolution_str == endptr)
		return (0);
	while (*endptr == ' ')
		endptr++;
	height = strtol(endptr, &endptr, 10);
	if (*endptr != '\0')
		return (0);
	if (width <= 0 || height <= 0
		|| width > MAX_WIDTH || height > MAX_HEIGHT)
	{
		printf("Erreur : valeurs de résolution aberrantes\n");
		return (0);
	}
	return (1);
}

int	validate_rgb(const char *rgb_str, int *rgb_arr)
{
	char	*token;
	char	*str;
	char	*ptr;
	int		i;
	int		value;

	i = 0;
	str = strdup(rgb_str);
	ptr = str;
	while ((token = strtok(ptr, ", ")) != NULL && i < 3)
	{
		value = atoi(token);
		if (value < 0 || value > 255)
		{
			free(str);
			return (0);
		}
		rgb_arr[i++] = value;
		ptr = NULL;
	}
	free(str);
	return (i == 3);
}

int	validate_texture_path(const char *path)
{
	const char	*extension;

	extension = strrchr(path, '.');
	if (extension == NULL)
	{
		return (0);
	}
	if (strcmp(extension, ".xpm") != 0)
	{
		return (0);
	}
	return (1);
}

int	handle_texture_path(char *key, char *value, t_map *map_info)
{
	char	**texture_path;

	texture_path = NULL;
	if (strcmp(key, "WE") == 0)
		texture_path = &map_info->west_texture_path;
	else if (strcmp(key, "NO") == 0)
		texture_path = &map_info->north_texture_path;
	else if (strcmp(key, "SO") == 0)
		texture_path = &map_info->south_texture_path;
	else if (strcmp(key, "EA") == 0)
		texture_path = &map_info->east_texture_path;
	if (texture_path != NULL && validate_texture_path(value))
	{
		*texture_path = strdup(value);
		if (*texture_path == NULL)
		{
			printf("Erreur d'allocation pour la texture %s\n", key);
			return (0);
		}
		return (1);
	}
	return (0);
}

int	handle_color(char *key, char *value, t_map *map_info)
{
	int	rgb_arr[3];
	int	i;

	if ((strcmp(key, "F") == 0 || strcmp(key, "C") == 0) && validate_rgb(value, rgb_arr))
	{
		i = 0;
		while (i < 3)
		{
			if (strcmp(key, "F") == 0)
				map_info->floor_color[i] = rgb_arr[i];
			else
				map_info->ceiling_color[i] = rgb_arr[i];
			i++;
		}
		if (strcmp(key, "F") == 0)
			map_info->floor_color_set = true;
		else
			map_info->ceiling_color_set = true;
		return (1);
	}
	return (0);
}

int	handle_texture_and_color(char *key, char *value, t_map *map_info)
{
	if (!handle_texture_path(key, value, map_info) && !handle_color(key, value, map_info))
	{
		return (0);
	}
	return (1);
}

int	parse_config_line(char* line, t_map *map_info)
{
	char	*key;
	char	*value;

	key = strtok(line, " \t");
	value = strtok(NULL, "\n");
	if (key != NULL && value != NULL)
	{
		if (strcmp(key, "R") == 0 && validate_resolution(value))
		{
		}
		else
		{
			return (handle_texture_and_color(key, value, map_info));
		}
		return (1);
	}
	return (0);
}

int	read_and_split_lines(int fd, char **line,
		char **saveptr, int *config_completed)
{
	static char	buffer[BUFFER_SIZE + 1];
	ssize_t		bytes_read;

	if (*saveptr == NULL || **saveptr == '\0')
	{
		bytes_read = read(fd, buffer, BUFFER_SIZE);
		if (bytes_read <= 0)
			return (0);
		buffer[bytes_read] = '\0';
		*saveptr = buffer;
	}
	*line = strtok_r(*saveptr, "\n", saveptr);
	if (*line != NULL && (*line)[0] == '1')
	{
		*config_completed = 1;
		return (0);
	}
	return (*line != NULL);
}

int	process_lines(int fd, t_map *map_info)
{
	char	*line;
	char	*saveptr;
	int		config_completed;

	saveptr = NULL;
	config_completed = 0;
	while (read_and_split_lines(fd, &line, &saveptr,
		&config_completed) && !config_completed)
	{
		if (!parse_config_line(line, map_info))
		{
			printf("Erreur de parsing à la ligne : %s\n", line);
			return (0);
		}
	}
	if (config_completed)
	{
		return (1);
	}
	else
	{
		return (0);
	}
}

int	parse_config_file(const char* file_path, t_map *map_info)
{
	int	fd;
	int	result;

	fd = open(file_path, O_RDONLY);
	if (fd == -1)
	{
		perror("Erreur lors de l'ouverture du fichier");
		return (0);
	}
	result = process_lines(fd, map_info);
	close(fd);
	return (result);
}

int	is_wall_line(const char* line)
{
	int	i;

	i = 0;
	while (line[i] != '\0')
	{
		if (line[i] != '1')
		{
			return (0);
		}
		i++;
	}
	return (1);
}

int process_player_position(char *line, t_map *map_info, int line_number)
{
    char *player_pos;
    char directions[] = "NSEW";
    int i;

    i = 0;
    while (directions[i] != '\0')
	{
        player_pos = strchr(line, directions[i]);
        if (player_pos != NULL)
		{
            if (map_info->player_direction != 0)
			{
                printf("Erreur : Plusieurs positions de départ du joueur trouvées\n");
                return (0);
            }
            map_info->player_x = player_pos - line;
            map_info->player_y = line_number;
            map_info->player_direction = *player_pos;
            int line_length = (int)strlen(line);
            if (map_info->player_x == 0 || map_info->player_x == line_length - 1 ||
                line_number == 0 || line_number == map_info->height - 1 ||
                line[map_info->player_x] == '1')
			{
                printf("Erreur : Position du joueur invalide ou sur un mur\n");
                return (0);
            }
            *player_pos = '0';
            return (1);
        }
        i++;
    }
    return 1;
}

int parse_map_line(char* line, t_map *map_info, int line_number)
{
    int len = strlen(line);
    if (!process_player_position(line, map_info, line_number))
    {
        return (0);
    }
    if (line[0] != '1' || line[len - 1] != '1')
    {
        printf("Erreur : la ligne de carte ne commence ou ne finit pas par 1 : %s\n", line);
        return (0);
    }
    return (1);
}


ssize_t	read_file_to_buffer(int fd, char *buffer, size_t buffer_size)
{
	return (read(fd, buffer, buffer_size));
}

int handle_map_line(char *line, t_map *map_info, int *start_reading_map, int *line_number)
{
    if (*start_reading_map)
    {
        if (!parse_map_line(line, map_info, *line_number))
        {
            return (0);
        }
        (*line_number)++;
    }
    else
    {
        if (is_wall_line(line))
        {
            *start_reading_map = 1;
            if (!parse_map_line(line, map_info, *line_number))
            {
                return (0);
            }
            (*line_number)++;
        }
    }
    return (1);
}


int	process_map_lines(char *buffer, t_map *map_info,
		int *start_reading_map, int *line_number)
{
	char	*line;
	char	*saveptr;

	saveptr = NULL;
	line = strtok_r(buffer, "\n", &saveptr);
	while (line != NULL)
	{
		if (!handle_map_line(line, map_info,
			start_reading_map, line_number))
		{
			return (0);
		}
		line = strtok_r(NULL, "\n", &saveptr);
	}
	return (1);
}

int	open_file_for_parsing(const char *file_path)
{
	int	fd;

	fd = open(file_path, O_RDONLY);
	if (fd == -1)
	{
		perror("Erreur lors de l'ouverture du fichier de la carte");
	}
	return (fd);
}

int	parse_map(const char* file_path, t_map *map_info)
{
	char	buffer[BUFFER_SIZE + 1];
	ssize_t	bytes_read;
	int		fd;
	int		start_reading_map;
	int		line_number;

	start_reading_map = 0;
	line_number = 0;
	fd = open_file_for_parsing(file_path);
	if (fd == -1)
		return (0);
	while ((bytes_read = read_file_to_buffer(fd, buffer, BUFFER_SIZE)) > 0)
	{
		buffer[bytes_read] = '\0';
		if (!process_map_lines(buffer, map_info,
			&start_reading_map, &line_number))
		{
			close(fd);
			return (0);
		}
	}
	close(fd);
	if (start_reading_map)
		return (1);
	else
		return (0);
}

int	parse_file(const char* file_path, t_map *map_info)
{
	if (!parse_config_file(file_path, map_info))
	{
		printf("Erreur lors du parsing de la configuration\n");
		return (1);
	}
	if (!parse_map(file_path, map_info))
	{
		printf("Erreur lors du parsing de la carte\n");
		return (1);
	}
	return (0);
}

void calculate_ray_and_deltadist(t_data *data, t_ray *ray, int x)
{
    double camera_x;
    
    camera_x = 2 * x / (double)MAX_WIDTH - 1; 
    ray->ray_dir_x = data->player->dir_x
        + data->player->plane_x * camera_x;
    ray->ray_dir_y = data->player->dir_y
        + data->player->plane_y * camera_x;
    ray->delta_dist_x = fabs(1 / ray->ray_dir_x);
    ray->delta_dist_y = fabs(1 / ray->ray_dir_y);
    ray->hit = 0;
}

void calculate_step_and_sidedist(t_data *data, t_ray *ray)
{
    if (ray->ray_dir_x < 0)
    {
        ray->step_x = -1;
        ray->side_dist_x = (data->player->pos_x
            - ray->map_x) * ray->delta_dist_x;
    }
    else
    {
        ray->step_x = 1;
        ray->side_dist_x = (ray->map_x + 1.0
            - data->player->pos_x) * ray->delta_dist_x;
    }
    if (ray->ray_dir_y < 0)
    {
        ray->step_y = -1;
        ray->side_dist_y = (data->player->pos_y
            - ray->map_y) * ray->delta_dist_y;
    }
    else
    {
        ray->step_y = 1;
        ray->side_dist_y
            = (ray->map_y + 1.0 - data->player->pos_y)
            * ray->delta_dist_y;
    }
}

void perform_dda(t_data *data, t_ray *ray)
{
    while (ray->hit == 0)
    {
        // Vérifie si le rayon est sorti des limites de la carte
        if (ray->map_x < 0 || ray->map_x >= data->map->width ||
            ray->map_y < 0 || ray->map_y >= data->map->height)
        {
            ray->hit = 1;
            break;
        }

        if (ray->side_dist_x < ray->side_dist_y)
        {
            ray->side_dist_x += ray->delta_dist_x;
            ray->map_x += ray->step_x;
            ray->side = 0;
        }
        else
        {
            ray->side_dist_y += ray->delta_dist_y;
            ray->map_y += ray->step_y;
            ray->side = 1;
        }

        // Vérifie si le rayon a touché un mur
        if (data->map->map[ray->map_y][ray->map_x] > 0)
            ray->hit = 1;
    }
}


void calculate_dist(t_data *data, t_ray *ray)
{
    if (ray->side == 0)
        ray->perp_wall_dist
            = (ray->map_x - data->player->pos_x
            + (1 - ray->step_x) / 2) / ray->ray_dir_x;
    else
        ray->perp_wall_dist
            = (ray->map_y - data->player->pos_y
            + (1 - ray->step_y) / 2) / ray->ray_dir_y;
}

int calculate_height_wall(t_data *data, t_ray *ray)
{
    int line_height;

    (void)data;
    line_height = (int)(MAX_HEIGHT / ray->perp_wall_dist);
    return (line_height);
}

void cast_ray(t_data *data, t_ray *ray, int x)
{
    init_ray(ray);
    calculate_ray_and_deltadist(data, ray, x);
    calculate_step_and_sidedist(data, ray);
    perform_dda(data, ray);
    calculate_dist(data, ray);
}

void	my_mlx_pixel_put(t_img *img, int x, int y, int color)
{
	char	*dst;

	dst = img->addr + (y * img->line_length + x * (img->bits_per_pixel / 8));
	*(unsigned int*)dst = color;
}

void	draw_floor(t_data *data)
{
	int	width;
	int	height;
	int	floor_color;
	int	y;
	int	x;

	width = MAX_WIDTH;
	height = MAX_HEIGHT;
    floor_color = (data->map->floor_color[0] << 16)
        | (data->map->floor_color[1] << 8) | data->map->floor_color[2];
	y = height / 2;
    while (y < height)
    {
		x = 0;
		while (x < width)
		{
			my_mlx_pixel_put(data->img, x, y, floor_color);
			x++;
		}
		y++;
	}
}

void draw_ceiling(t_data *data)
{
	int	width;
	int	height;
	int	ceiling_color;
	int	y;
	int	x;

	width = MAX_WIDTH;
	height = MAX_HEIGHT;
	ceiling_color = (data->map->ceiling_color[0] << 16)
        | (data->map->ceiling_color[1] << 8) | data->map->ceiling_color[2];
	y = 0;
	while (y < height / 2)
	{
		x = 0;
		while (x < width)
		{
			my_mlx_pixel_put(data->img, x, y, ceiling_color);
			x++;
		}
		y++;
	}
}



int get_wall_color(t_texture *texture, int x, int y)
{
    int pixel_index;
    int red;
    int green;
    int blue;
    int color;
    
    if (x >= 0 && x < texture->width && y >= 0 && y < texture->height)
    {
        pixel_index = (y * texture->line_length) + (x * (texture->bits_per_pixel / 8));
        red = (unsigned char)texture->addr[pixel_index + 2];
        green = (unsigned char)texture->addr[pixel_index + 1];
        blue = (unsigned char)texture->addr[pixel_index];
        color = (red << 16) | (green << 8) | blue;
        return (color);
    }
    return (0x000000);
}

void    set_image_pixel(t_img *image, int x, int y, int color)
{
    int pixel;
    
    pixel = y * (image->line_length / 4) + x;
    image->addr[pixel] = color;
}

int load_texture(t_mlx *mlx, t_texture *texture, char *path)
{
    texture->img = mlx_xpm_file_to_image(mlx->mlx, path, &texture->width, &texture->height);
    if (texture->img == NULL)
        return 0;
    texture->addr = mlx_get_data_addr(texture->img, &texture->bits_per_pixel, &texture->line_length, &texture->endian);
    return 1;
}

int get_pixel_from_texture(t_texture *tex, int x, int y)
{
    int pixel = y * tex->width + x;
    return *(int*)(tex->addr + pixel * 4);
}

void draw_walls(t_data *data, t_ray *ray, int x)
{
    int line_height = calculate_height_wall(data, ray);
    int draw_start = -line_height / 2 + MAX_HEIGHT / 2;
    if (draw_start < 0) draw_start = 0;
    int draw_end = line_height / 2 + MAX_HEIGHT / 2;
    if (draw_end >= MAX_HEIGHT) draw_end = MAX_HEIGHT - 1;

    t_texture *tex;
    if (ray->side == 0)
        tex = (ray->ray_dir_x > 0) ? &data->map->east_texture : &data->map->west_texture;
    else
        tex = (ray->ray_dir_y > 0) ? &data->map->south_texture : &data->map->north_texture;

    // Calcul de la position exacte sur le mur
    double wall_x = (ray->side == 0) ? data->player->pos_y + ray->perp_wall_dist * ray->ray_dir_y : data->player->pos_x + ray->perp_wall_dist * ray->ray_dir_x;
    wall_x -= floor(wall_x);

    // x coordinate on the texture
    int tex_x = (int)(wall_x * (double)tex->width);
    if ((ray->side == 0 && ray->ray_dir_x > 0) || (ray->side == 1 && ray->ray_dir_y < 0))
        tex_x = tex->width - tex_x - 1;

    for (int y = draw_start; y < draw_end; y++)
    {
        // Calcul pour déterminer la position y sur la texture
        int d = y * 256 - MAX_HEIGHT * 128 + line_height * 128;
        int tex_y = ((d * tex->height) / line_height) / 256;
        int color = get_pixel_from_texture(tex, tex_x, tex_y);
        my_mlx_pixel_put(data->img, x, y, color);
    }
}

void render(t_data *data)
{
    int width;
    int height;
    int clear_color;
    int y;
    int x;

    width = MAX_WIDTH;
    height = MAX_HEIGHT;
    clear_color = 0x000000;
    y = 0;
    while (y < height)
    {
        x = 0;
        while (x < width)
        {
            my_mlx_pixel_put(data->img, x, y, clear_color);
            x++;
        }
        y++;
    }
    draw_floor(data);
    draw_ceiling(data);
    x = 0;
    while (x < MAX_WIDTH)
    {
        t_ray ray;
        cast_ray(data, &ray, x);
        draw_walls(data, &ray, x);
        x++;
    }
    mlx_put_image_to_window(data->mlx->mlx, data->mlx->win, data->img->img, 0, 0);
}

t_key_state g_keystate = {0};

void	move_forward(t_player *player, double move_speed)
{
	player->pos_x += player->dir_x * move_speed;
	player->pos_y += player->dir_y * move_speed;
}

void	move_backward(t_player *player, double move_speed)
{
	player->pos_x -= player->dir_x * move_speed;
	player->pos_y -= player->dir_y * move_speed;
}

void rotate_right(t_player *player, double rot_speed)
{
	double olddir_x;
	double old_plane_x;

	olddir_x = player->dir_x;
	player->dir_x = player->dir_x * cos(-rot_speed) - player->dir_y * sin(-rot_speed);
	player->dir_y = olddir_x * sin(-rot_speed) + player->dir_y * cos(-rot_speed);
	old_plane_x = player->plane_x;
	player->plane_x = player->plane_x * cos(-rot_speed) - player->plane_y * sin(-rot_speed);
	player->plane_y = old_plane_x * sin(-rot_speed) + player->plane_y * cos(-rot_speed);
}

void	rotate_left(t_player *player, double rot_speed)
{
	double olddir_x;
	double old_plane_x;

	olddir_x = player->dir_x;
	player->dir_x = player->dir_x * cos(rot_speed) - player->dir_y * sin(rot_speed);
	player->dir_y = olddir_x * sin(rot_speed) + player->dir_y * cos(rot_speed);
	old_plane_x = player->plane_x;
	player->plane_x = player->plane_x * cos(rot_speed) - player->plane_y * sin(rot_speed);
	player->plane_y = old_plane_x * sin(rot_speed) + player->plane_y * cos(rot_speed);
}

void	move_left(t_player *player, double move_speed)
{
	player->pos_x -= player->plane_x * move_speed;
	player->pos_y -= player->plane_y * move_speed;
}

void	move_right(t_player *player, double move_speed)
{
	player->pos_x += player->plane_x * move_speed;
	player->pos_y += player->plane_y * move_speed;
}

int	handle_input(int keycode, t_data *data)
{
	const double	move_speed = 0.1;
	const double	rot_speed = 0.1;

	if (keycode == W_KEY)
		g_keystate.W = 1;
	if (keycode == S_KEY)
		g_keystate.S = 1;
	if (keycode == A_KEY)
		g_keystate.A = 1;
	if (keycode == D_KEY)
		g_keystate.D = 1;
	if (g_keystate.W)
		move_forward(data->player, move_speed);
	if (g_keystate.S)
		move_backward(data->player, move_speed);
	if (g_keystate.A)
		move_left(data->player, move_speed);
	if (g_keystate.D)
		move_right(data->player, move_speed);
	if (keycode == RIGHT_KEY)
		rotate_right(data->player, rot_speed);
	if (keycode == LEFT_KEY)
		rotate_left(data->player, rot_speed);
	return (0);
}

int init_mlx_and_window(t_mlx *mlx_info)
{
    mlx_info->mlx = mlx_init();

    if (mlx_info->mlx == NULL)
    {
        return (0);
    }
    mlx_info->win = mlx_new_window(mlx_info->mlx,
        MAX_WIDTH, MAX_HEIGHT, "Cub3D");
    if (mlx_info->win == NULL)
    {
        mlx_destroy_display(mlx_info->mlx);
        free(mlx_info->mlx);
        return (0);
    }
    return (1);
}

bool	check_wall(t_map *map_info, int x, int y)
{
	if (x < 0 || x >= map_info->width || y < 0 || y >= map_info->height)
		return (true);
	return (map_info->map[y][x] == '1');
}

bool is_position_valid(t_data *data, double x, double y)
{
    return (!check_wall(data->map, (int)x, (int)y));
}

void update_game(t_data *data, t_player *player)
{
    const double moveSpeed = 0.1;
    double buffer = 0.1;
    double newX = player->pos_x + player->dir_x * moveSpeed;
    double newY = player->pos_y + player->dir_y * moveSpeed;
    double buffer_x = buffer;
    double buffer_y = buffer;

    if (player->dir_x < 0)
    {
        buffer_x = -buffer;
    }
    if (player->dir_y < 0)
    {
        buffer_y = -buffer;
    }
    if (is_position_valid(data, newX + buffer_x, player->pos_y))
    {
        player->pos_x = newX;
    }
    if (is_position_valid(data, player->pos_x, newY + buffer_y))
    {
        player->pos_y = newY;
    }
}

int game_loop(t_data *data)
{
    update_game(data, data->player);
    render(data);
    return (0);
}

int initialize_game(char *filename, t_data *data,
        t_mlx *mlx_info, t_map *map_info, t_player *player)
{
    if (parse_file(filename, map_info) != 0)
    {
        printf("Error parsing the map file.\n");
        return (1);
    }
    if (validate_map(map_info) != 0)
    {
        printf("Invalid map.\n");
        free_map(map_info);
        return (1);
    }
    if (!init_mlx_and_window(mlx_info))
    {
        printf("Failed to initialize MLX and window\n");
        free_map(map_info);
        return (1);
    }
    init_img(data, mlx_info->mlx, MAX_WIDTH, MAX_HEIGHT);
    initialize_player(player);
    init_player(player, map_info);
    if (!init_all_textures(mlx_info, map_info))
    {
        printf("Failed to initialize textures\n");
        free_map(map_info);
        clean_exit(mlx_info, map_info);
        return (1);
    }
    set_window(data);
    return (0);
}

int main(int ac, char **av)
{
    t_map    map_info = {0};
    t_data   data;
    t_mlx    mlx_info = {0};
    t_player player = {0};

    if (check_arguments(ac, av) != 0)
    {
        printf("Argument check failed.\n");
        return (1);
    }
    data.mlx = &mlx_info;
    data.map = &map_info;
    data.player = &player;
    
    t_key_state key_state;
    memset(&key_state, 0, sizeof(t_key_state));

    
     if (initialize_game(av[1], &data, &mlx_info, &map_info, &player) != 0)
    {
        return (1);
    }
    mlx_loop_hook(data.mlx->mlx, game_loop, &data);
    mlx_key_hook(data.mlx->win, handle_input, &data);
    mlx_loop(data.mlx->mlx);
    free_map(&map_info);
    clean_exit(&mlx_info, &map_info);
    return (0);
}
